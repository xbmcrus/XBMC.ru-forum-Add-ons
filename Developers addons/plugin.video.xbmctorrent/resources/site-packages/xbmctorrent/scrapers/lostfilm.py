# -*- coding: utf-8 -*-

import sys, xbmc, xbmcgui
from urlparse import urljoin
from xbmctorrent import plugin
from xbmctorrent.scrapers import scraper
from xbmctorrent.ga import tracked
from xbmctorrent.caching import cached_route
from xbmctorrent.utils import ensure_fanart

BASE_URL = "http://www.lostfilm.tv/"
LOGIN_URL = "http://login1.bogi.ru/"

HEADERS = {
    'Referer'        :  BASE_URL,
    'Accept'         : 'text/html, application/xml, application/xhtml+xml, image/png, image/jpeg, image/gif, image/x-xbitmap, */*',
    'Accept-Language': 'ru-RU,ru;q=0.9,en;q=0.8',
    'Accept-Encoding': 'identity, *;q=0'
}

# Cache TTLs
DEFAULT_TTL = 300 # 5 minutes

_cookiejar = None
_db_connect = None

def udec(x):
    return x.decode('utf-8')

def uenc(x):
    return x.encode('utf-8')

def url_get(url, params={}, headers={}, post = None):
    global _cookiejar
    import xbmcvfs, urllib2
    from xbmctorrent.utils import url_get as url_get_origin

    if not _cookiejar:
        import os, xbmc, cookielib

        sid_file = os.path.join(xbmc.translatePath('special://temp/'), plugin.id, 'LostFilm.cookies.dat') #
        if not xbmcvfs.exists(os.path.dirname(sid_file)):
            xbmcvfs.mkdir(os.path.dirname(sid_file))

        _cookiejar = cookielib.MozillaCookieJar(sid_file)

        if not xbmcvfs.exists(sid_file):
            _cookiejar.save()

        _cookiejar.load()

    cookie_handler = urllib2.HTTPCookieProcessor(_cookiejar)
    result = url_get_origin(url, params, headers, post, handlers=[cookie_handler])
    _cookiejar.save()

    return result

@scraper("LostFilm.tv", "http://www.lostfilm.tv/Tmpl/LostFilm/img/logo.gif", plugin.get_setting("lostfilm_enabled", bool))
@plugin.route("/lostfilm/index/<page>", options={"page" : "0"})
@cached_route(ttl=DEFAULT_TTL, content_type="tvshows")
@ensure_fanart
def lostfilm_index(page = ""):

    from bs4 import BeautifulSoup
    from urlparse import urljoin
    from contextlib import closing
    from xbmctorrent.utils import SafeDialogProgress
    from xbmctorrent.acestream import ace_supported

    page = int(page)
    with closing(SafeDialogProgress(delay_close=0)) as dialog:
        dialog.create(plugin.name)
        dialog.update(percent=0, line1="Получение информации ...", line2="", line3="")

        try:
            html_data = url_get(urljoin(BASE_URL, "browse.php"), params={"o":page*15}, headers=HEADERS)
            soup = BeautifulSoup(html_data, "html5lib", from_encoding="windows-1251")
            div_body = soup.select("div.content_body")
            episodes = div_body[0].findAll("span", class_="torrent_title")
        except:
            plugin.log.error("Unexpected error: %s" % sys.exc_info()[0])
            xbmcgui.Dialog().ok(plugin.name, "Не удалось получить данные от сервера.")
            return

        yield {
            "label": "[COLOR FF00FF00][Полный список сериалов][/COLOR]",
            "path": plugin.url_for("lostfilm_all"),
        }

        done = 0
        for episode in episodes:
            tvshow_name = episode.find_previous_sibling("a").img["title"] # needs if not found in db
            a_download = episode.find_next("a", class_="a_download")["onclick"]
            tvshowid, season, episode_num = a_download[a_download.rfind("(")+2:a_download.rfind(")")-1].split("','")

            if dialog.iscanceled():
                return

            item = _lostfilm_updateitem_from_db({
                "label" : "[COLOR FFFFFFCC][%s.%s][/COLOR] [COLOR FFFFFFFF][B]%s[/B][/COLOR]: %s" % (season, episode_num, tvshow_name, episode.text),
                "path"  : plugin.url_for("lostfilm_play", showid=tvshowid, season=season, episode=episode_num),
                "is_playable" : True,
                "info" : {
                    "title"   : episode.text,
                    "season"  : season,
                    "episode" : episode_num
                }
            }, tvshowid)

            if not "-" in episode_num and int(episode_num) == 99:
                item.update({
                    "label" : "[COLOR FFFFFFCC][%s.xx][/COLOR] [COLOR FFFFFFFF][B]%s[/B][/COLOR]: %s" % (season, tvshow_name, episode.text),
                    "is_playable" : not ace_supported(),
                    "info" : {
                        "title"   : episode.text,
                        "season"  : season,
                        "episode" : "all"
                    }
                })

            done += 1
            dialog.update(
                percent = int(done * 100.0 / len(episodes)),
                line2 = item.get("info", {}).get("tvshowtitle", "") or item.get("info", {}).get("title", "") or item["label"],
                line3 = ""
            )

            yield item;

        if len(episodes) >= 15:
            yield {
                "label": "[COLOR FF00FF00][Далее >][/COLOR]",
                "path": plugin.url_for("lostfilm_index", page=page + 1),
            }

        _lostfilm_close_dbase()

@plugin.route("/lostfilm/all/")
@cached_route(ttl=DEFAULT_TTL, content_type="tvshows")
@ensure_fanart
def lostfilm_all():
    from bs4 import BeautifulSoup
    from urlparse import urljoin
    from contextlib import closing
    from xbmctorrent.utils import SafeDialogProgress

    with closing(SafeDialogProgress(delay_close=0)) as dialog:
        dialog.create(plugin.name)
        dialog.update(percent=0, line1=u"Получение информации ...", line2="", line3="")

        try:
            html_data = url_get(urljoin(BASE_URL, "serials.php"), headers=HEADERS)
            soup = BeautifulSoup(html_data, "html5lib", from_encoding="windows-1251")
            div_mid = soup.select("div.mid")
            tvshows = div_mid[0].findAll("a", class_="bb_a")
        except:
            plugin.log.error("Unexpected error: %s" % sys.exc_info()[0])
            xbmcgui.Dialog().ok(plugin.name, u"Не удалось получить данные от сервера")
            return

        done = 0
        for tvshow in tvshows:
            tvshowid = tvshow["href"].replace("/browse.php?cat=", "")
            tvshow_name = "[COLOR FFFFFFFF][B]%s[/B][/COLOR] %s" % (tvshow.contents[0], tvshow.contents[2].text)

            if dialog.iscanceled():
                return

            item = _lostfilm_updateitem_from_db({
                "label" : tvshow_name,
                "path"  : plugin.url_for("lostfilm_tvshow", showid=tvshowid, season=0),
                "is_playable" : False,
                "info"  : {
                    "title" : "%s %s" % (tvshow.contents[0], tvshow.contents[2].text)
                }
            }, tvshowid)

            done += 1
            dialog.update(
                percent = int(done * 100.0 / len(tvshows)),
                line2 = item.get("info", {}).get("tvshowtitle", "") or item.get("info", {}).get("title", "") or item["label"],
                line3 = ""
            )

            yield item;           

        _lostfilm_close_dbase()

@plugin.route("/lostfilm/show/<showid>/<season>")
@cached_route(ttl=DEFAULT_TTL, content_type="episodes")
@ensure_fanart
def lostfilm_tvshow(showid, season):
    from bs4 import BeautifulSoup
    from urlparse import urljoin
    from contextlib import closing
    from xbmctorrent.utils import SafeDialogProgress
    from xbmctorrent.acestream import ace_supported

    with closing(SafeDialogProgress(delay_close=0)) as dialog:
        dialog.create(plugin.name)
        dialog.update(percent=0, line1="Получение информации ...", line2="", line3="")

        try:
            html_data = url_get(urljoin(BASE_URL, "browse.php"), params={"cat" : showid}, headers=HEADERS)
            soup = BeautifulSoup(html_data, "html5lib", from_encoding="windows-1251")
            div_mid = soup.select("div.mid")
            episodes = div_mid[0].findAll("td", class_="t_episode_title")
        except:
            import xbmcgui
            plugin.log.error("Unexpected error: %s" % sys.exc_info()[0])
            xbmcgui.Dialog().ok(plugin.name, "Не удалось получить данные от сервера")
            return

        show_info = _lostfilm_get_db_info(showid)
        showid = int(showid)
        season = int(season)

        done = 0
        for episode in episodes:
            script = episode["onclick"]
            tvshowid, season_num, episode_num = script[script.rfind("(")+2:script.rfind(")")-1].split("','")

            if season > 0 and season != int(season_num):
                continue

            is_full_season = (not "-" in episode_num and int(episode_num) == 99) or ("." in season_num and "-" in episode_num)
            nobr = episode.findAll("nobr")[0]
            if is_full_season:
                episode_name = nobr.contents[0].text
                label = "[COLOR FFFFFFCC][%s.xx][/COLOR] [COLOR FF00FF00][B]%s[/B][/COLOR]" % (season_num, episode_name)
            else:
                episode_name = "%s %s" % (nobr.contents[0].text, _safe_list_get(nobr.contents, 2, ""))
                label = "[COLOR FFFFFFCC][%s.%s][/COLOR] [COLOR FFFFFFFF][B]%s[/B][/COLOR] %s" % (
                    season_num, episode_num, nobr.contents[0].text, _safe_list_get(nobr.contents, 2, ""))

            if dialog.iscanceled():
                return

            item = _lostfilm_updateitem_from_info({
                "label" : label,
                "path"  : plugin.url_for("lostfilm_play", showid=tvshowid, season=season_num, episode=episode_num),
                "is_playable" : True,
                "info"  : {
                    "title"   : episode_name,
                    "season"  : season_num,
                    "episode" : episode_num
                }
            }, show_info)

            if is_full_season and ace_supported():
                item.update({ "is_playable" : False })

            done += 1
            dialog.update(
                percent = int(done * 100.0 / len(episodes)),
                line2 = item.get("info", {}).get("tvshowtitle", "") or item.get("info", {}).get("title", "") or item["label"],
                line3 = ""
            )

            yield item;           

        _lostfilm_close_dbase()


@plugin.route("/lostfilm/play/<showid>/<season>/<episode>")
@cached_route(ttl=DEFAULT_TTL, content_type="episodes")
@ensure_fanart
def lostfilm_play(showid, season, episode):
    import re, xbmcgui
    from urlparse import urljoin
    from contextlib import closing
    from bs4 import BeautifulSoup
    from xbmctorrent.acestream import ace_supported
    from xbmctorrent.magnet import generate_magnet
    from xbmctorrent.utils import SafeDialogProgress, get_quality_from_name

    with closing(SafeDialogProgress(delay_close=0)) as dialog:
        dialog.create(plugin.name)
        dialog.update(percent=0, line1="Получение информации о релизе...", line2="", line3="")

        params = { "c" : showid, "s" : season, "e" : episode }

        try:
            html = url_get(urljoin(BASE_URL, "nrdr.php"), params=params)
            # catch 'log in first' then login
            if html.find("log in first") >= 0:
                dialog.update(percent=10, line2="Требуется авторизация. Авторизация...")
                if not plugin.get_setting("lostfilm_login") and not plugin.get_setting("lostfilm_passwd"):
                    plugin.notify("Проверьте настройки авторизации.", delay=15000)
                    return 

                _lostfilm_login()

            dialog.update(percent=30, line2="Загрузка.", line3="")
            html = url_get(urljoin(BASE_URL, "nrdr.php"), params=params)

            if html.find("log in first") >= 0:
                xbmcgui.Dialog().ok(plugin.name, "Авторизация неудалась. Проверьте настройки.")
                return

        except:
            plugin.log.error("Unexpected error: %s" % sys.exc_info()[0])
            xbmcgui.Dialog().ok(plugin.name, "Не удалось получить данные от сервера")
            return

        dialog.update(percent=50, line2="Обработка данных.")
        soup = BeautifulSoup(html, "html5lib", from_encoding="windows-1251")

        releases = soup.findAll("a", href=re.compile("tracktor.in"), style=re.compile("bold"))

        select_items = []
        for release in releases: 
            span = release.find_next("span")
            select_items.append(span.contents[0])

        select = xbmcgui.Dialog().select("Выберите желаемое качество", select_items)

        if select >= 0:
            selected = releases[select]
            torrent_url = selected["href"]

            if ((not "-" in episode and int(episode) == 99) or ("." in season and "-" in episode)) and ace_supported():
                if "." in season:
                    season = season[:season.find(u".")]

                show_info = _lostfilm_get_db_info(showid)
                plugin.add_sort_method("label")

                try:
                    from bencode import bencode, bdecode
                    torrent_data = url_get(torrent_url, headers=HEADERS)
                    metadata = bdecode(torrent_data)
                except:
                    plugin.log.error("Cannot get data from remote server")
                    xbmcgui.Dialog().ok(plugin.name, "Не удалось получить данные от сервера")
                    return

                e = re.compile("(e[\d]+)?e([\d]+)\.", re.I|re.S|re.U)
                for index, item in enumerate(metadata["info"]["files"]):
                    file_name = " / ".join(item["path"])
                    print file_name
                    r = e.search(file_name)
                    if r: 
                        if r.group(1):
                            episode = r.group(1)[1:]
                        else:
                            episode = r.group(2)
                    else: 
                        episode = u""
                    yield _lostfilm_updateitem_from_info({
                        "label"       : file_name,
                        "path"        : plugin.url_for("torrent_play", url=torrent_url, index=index, name=file_name),
                        "is_playable" : True,
                        "info"        : {
                            "title"   : file_name,
                            "season"  : season,
                            "episode" : episode
                        },
                        "stream_info" : get_quality_from_name(file_name)
                    }, show_info)
                _lostfilm_close_dbase()
            else:
                plugin.redirect(plugin.url_for("play", uri=torrent_url))


def _lostfilm_login():
    from urlparse import urljoin
    from urllib import urlencode
    from bs4 import BeautifulSoup

    params = {
        "referer" : BASE_URL,
    }
    values = {
        "login"     : plugin.get_setting("lostfilm_login"),
        "password"  : plugin.get_setting("lostfilm_passw"),
        "module"    : 1,
        "target"    : "http://lostfilm.tv/",
        "repage"    : "user",
        "act"       : "login"
    }

    login_url = "%s?%s" % (urljoin(LOGIN_URL, "login.php"), urlencode(params))

    html = url_get(login_url, post=values, headers=HEADERS)
    soup = BeautifulSoup(html, from_encoding="utf-8")

    #-- step 2
    HEADERS["Referer"] = login_url
    HEADERS["Origin"] = LOGIN_URL
    HEADERS["Content-Type"] = "application/x-www-form-urlencoded"

    values = {}
    for rec in soup("input", type="hidden"):
        values[rec["name"].encode("utf-8")] = (rec.has_attr("value") and rec["value"] or "").encode("utf-8")

    html = url_get(soup.find("form")["action"], post=values, headers=HEADERS)

    HEADERS["Referer"] = BASE_URL # restore referer
    del HEADERS["Origin"]         # delete unneeded origin

    return

def _lostfilm_updateitem_from_db(item, showid):
    return _lostfilm_updateitem_from_info(item, _lostfilm_get_db_info(showid))

def _lostfilm_updateitem_from_info(item, result = {}):
    if result:
        item.setdefault("info", {}).update(result)
        item.update({ 
            "icon"     : result["cover"] or "",
            "thumbnail": result["cover"] or ""
        })
        item.setdefault("properties", {}).update({
            "fanart_image": result["cover"] or ""
        })
    return item

def _lostfilm_get_meta(showid):
    import re, urllib
    from bs4 import BeautifulSoup
    from urlparse import urljoin

    try:
        html = url_get(urljoin(BASE_URL, "browse.php"), params={ "cat": showid })
    except:
        plugin.log.info("Cannot get data from lostfilm")
        return None

    if not html:
        plugin.log.info("Cannot get data from lostfilm")
        return None

    soup = BeautifulSoup(html, "html5lib", from_encoding="windows-1251")
    div_mid = soup.select("div.mid")[0]
    div_main = div_mid.find("div")

    full_title = div_main.h1.text
    info = {
      #"title" : full_title
    }

    br1 = full_title.find(u"(")
    br2 = full_title.find(u")")

    if br1 >= 0 and br2 >= 0 and br1 < br2:
        info["tvshowtitle"] = full_title[:br1].strip()
        info["original_title"] = full_title[br1+1:br2].strip()
    else:
        info["tvshowtitle"] = full_title.strip()
        info["original_title"] = full_title.strip()

    info["cover"] = urljoin(BASE_URL, div_main.img["src"]).encode("utf-8")
    info["plot"] = div_main.find("div", class_="content").find_next("span").text.strip()

    r = re.compile('<br clear="both"/>(.+?)<div class="content">', re.U|re.S).search(unicode(div_main))
    if r:
        description = r.group(1).replace(u"<br/>", u"").replace(u"<span>", u"").replace(u"</span>", u"")
        for line in [line.strip() for line in description.split(u"\n") if line.strip()]:
            if u"Страна:" in line:
                name, value = line.split(u":")
                info["country"] = value.strip()
            elif u"Год выхода:" in line:
                name, value = line.split(u":")
                info["year"] = value.strip()
            elif u"Жанр:" in line:
                name, value = line.split(u":")
                info["genre"] = value.strip()
            """
            elif u"Количество сезонов:" in line:
                name, value = line.split(u":")
                info.setdefault("properties", {}).update({
                    "total_seasons" : value.strip()
                })
            """

    return info

def _lostfilm_get_db_info(showid):
    import pickle, sqlite3

    connection = _lostfilm_dbase()
    result = {}
    try:
        cursor = connection.cursor()
        cursor.execute("SELECT data FROM meta WHERE id = '%s';" % showid)
        row = cursor.fetchone()
        cursor.close()

        if row:
            try:
                obj = pickle.loads(row[0])
            except:
                pass
            else:
                return obj

        result = _lostfilm_get_meta(showid)

        if result:
            obj = sqlite3.Binary(pickle.dumps(result))
            cursor = connection.cursor()
            cursor.execute('replace into meta(id,data) values(?,?)', (showid, obj))
            connection.commit()
            cursor.close()
            
    except Exception, e:
        plugin.log.info(e)
        pass

    return result

def _lostfilm_dbase():
    global _db_connect
    if not _db_connect:
        import os, sqlite3, xbmcvfs
        from xbmctorrent.common import RESOURCES_PATH

        db_name = os.path.join(RESOURCES_PATH, "db", "lostfilm.db" )

        first = False
        if not xbmcvfs.exists(db_name):
            first = True

        _db_connect = sqlite3.connect(database=db_name)

        if first:
            cursor = _db_connect.cursor()
            cursor.execute('pragma auto_vacuum=1')
            cursor.execute('create table meta(id varchar(20) unique, data blob)')
            _db_connect.commit()
            cursor.close()
            
    return _db_connect

def _lostfilm_close_dbase():
    global _db_connect
    if _db_connect:
        _db_connect.close()
        _db_connect = None

def _safe_list_get(l, idx, default=""):
  try:
    return l[idx]
  except IndexError:
    return default
